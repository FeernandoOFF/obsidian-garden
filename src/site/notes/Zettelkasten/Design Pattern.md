---
{"dg-publish":true,"permalink":"/zettelkasten/design-pattern/","title":"Design Pattern","tags":["core/tech/fundamentals/design-patterns","status/todo"],"created":"2022-10-24T23:09:55.000+01:00"}
---



## What is a Design Pattern?
> Is a proven solution to a common problem

Similar to architecture patterns, design patterns offer guidelines and best practices at a more granular level within the app. They help make the code testable, reusable, and readable.


## Most used design patterns



2. [[Zettelkasten/Singleton Pattern\|Singleton Pattern]] - used when only one instance of a class is needed throughout the application.
3. Factory - used when creating objects is complex and requires encapsulation of object creation logic.
4. [[Observer Pattern\|Observer Pattern]]- used for event-driven systems where objects need to be notified of changes in other objects.
5. [[Zettelkasten/Delegate Pattern\|Delegate Pattern]] - used to allow objects to communicate and pass data between each other.
6. Adapter - used to adapt one interface to another, especially when integrating with third-party libraries or systems.
7. Facade - used to provide a simplified interface to a complex system or library.
8. Command - used to encapsulate a request as an object, allowing it to be queued or logged.
9. Iterator - used to provide a way to access the elements of a collection without exposing its underlying implementation.
10. Strategy - used to encapsulate algorithms and make them interchangeable.
11. Decorator - used to dynamically add behavior to objects at runtime.
12. Template Method - used to define the skeleton of an algorithm and allow subclasses to implement specific steps.
13. Composite - used to represent objects as a tree structure, allowing them to be treated as individual objects or groups.
14. State - used to encapsulate the behavior of an object based on its internal state.
15. Proxy - used to provide a placeholder for another object to control access, especially for expensive or remote resources.
16. Builder - used to separate the construction of a complex object from its representation, allowing different representations to be created.
17. Chain of Responsibility - used to allow multiple objects to handle a request, each object trying to handle it before passing it on to the next object.
18. Flyweight - used to minimize memory usage by sharing common parts of objects between multiple instances.
19. Interpreter - used to interpret a language or grammar by defining a representation for its grammar.
20. Memento - used to capture and restore an object's internal state without violating encapsulation.

## References
